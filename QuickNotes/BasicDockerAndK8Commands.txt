//-----------------------------------------------------------------------------------------------------------------
            Basic docker cmd
//-----------------------------------------------------------------------------------------------------------------

>> Pull nginx image
docker pull nginx:latest

>> List all docker images present in system
docker images

>> Run docker image as container. Give name to container 'webserver'
docker run --publish 80:80 --name webserver nginx
Note: use -d to run in detached mode

>> show all running and terminated container
docker ps -a

>> Stop running container
docker stop webserver

>> Kill running container
docker kill webserver

>> remove docker container from local machine (stopped state)
docker rm webserver

docker rm  $(docker ps -a -q)     # Removes all stoped container

docker rmi [imageName]            # Delees the image

docker system prune -a            # Removes all images not in use by any container

>> Docker compose allows users to create yaml file to start multiple service/containers with defined attribute.


docker build -t [name:tag] .     # builds an image using a Dockerfile located in the same folder

docker build -t [name:tag] -f [fileName]     # builds an image using a Dockerfile located in different folder

docker tag [imageName] [name:tag]            # Tag an existing image


//-----------------------------------------------------------------------------------------------------------------
            Volume commands
//-----------------------------------------------------------------------------------------------------------------
docker create volume [volume name]                      # Creaes a new volume

docker volume ls                                        # List the volumes

docker volume inspect [Volume Name]                     # Displays the volume info

docker volume rm [Volume Name]                          # Deletes a volume

docker volume prune                                     # Delete all volume not mountedd



//-----------------------------------------------------------------------------------------------------------------
            YAML
//-----------------------------------------------------------------------------------------------------------------
YAML : YAML Ain't Markup Language
Seialization standard and deafult for docker

YAML Lint to parse and raise warring if there is any issue


//-----------------------------------------------------------------------------------------------------------------
            Docker compose
//-----------------------------------------------------------------------------------------------------------------
Define and run multi container application
Define using YAML files
Run using the dokcer CLI with the compose plugin (Docker compse)

docker compose vs docker-compse: 
    - docker-compse was Compose V1  wich uses python in backend
    - dokcer compose is introduce in Compose V2 (DockerCon Live 2022). Faster version
        - Installed with Docker Desktop
            - Linux: apt-get install docker compose-plugin

-- Docker compose commands

docker compose build                                # Build the images

docker compose start                                # Start the containers

docker compose stop                                 # stop the containers

docker compose up -d                                # Build and start

docker compose ps                                   # List what's running

docker compose rm                                   # Remove from memory

docker compose down                                 # Stop and remove

docker compose log                                  # Get the logs

docker compose exec [container] bash                # Run a command in a conainer

Note: Once docker compose command run, we can not create another container as earlier instance already have containers running but with Compose V2 its possible.
//------ Compose V2 commands

docker compose --project-name test1 up -d           # Run an instance as a projet

docker compose -p test2 up -d                       # shortcut of above command

docker compose compose ls                           # List running projects

docker compose cp [containerID]:[SRC_PATH] [DEST_PATH] # copy files from the containers

docker compose cp [SRC_PATH] [containerID]:[DEST_PATH] # copy files to the containers


_________________________________________________________________________________________________________________________________________________________________________________________________
//-----------------------------------------------------------------------------------------------------------------
            Kubernetes a.k.a. K8s
//-----------------------------------------------------------------------------------------------------------------
Originated from Google
v1.0 releaseed on July 2015
3rd gen container schduler from Google
   - Previously Google internal project: Bor and Omega
Donated to the Cloud Native Computing Foundation (CNCF): www.cncf.io

What is Kubernetes?
- K8x is the leading continer orchestration tool
- Designed as a looly coupled collection of componentes centered around deploying, maintainig and scalin workloads
- Vendor nutral

What K8s can do?
- Service discovery and load balancing
- Storage orchestration
  - Loal or Cloud based
- Automated rollouts and rollbacks
- self healing
- secre and configuratio management
- use the same API across on-premise and every cloud providers

What K8s can't do?
- Does not deploy source code
- Does not build your application
- Does not provide application-level servies
  - Mesage buses, databases, caches etc


//-----------------------------------------------------------------------------------------------------------------
            K8s Resources
//-----------------------------------------------------------------------------------------------------------------
 https://kubernetes.io/docs/concepts/overview/
 
Local K8s (Requires Virtualization)
- Docker Desktop
    - Limited to 1 Node
- MicroK8s (From Ubuntu)
    - Multiple Nodes
- Minikube
    -  Multiple Nodes
- 'Kind' :runs over Docker Desktop and provide extra functionality
    - Multiple Nodes

Note: Minikube can be installed on Hyper-V or VirtualBox


Minikuvbe Hyper-V Installation:
- Run windows terminal or powershell in admin mode
- Install Chocolatey package manager
- Run: choco install minikube
- Create network switch
    - New-VMSwitch -Name "MinikubeNAT" -AllowManagement $True - NetAdapterName "<adapter_name>"
- Start Minikube
    - minikuber start --vm-driver hyperv --hperv-virtual-switch "MinikubeNAT"
- Switch context
    - kubectl config use-context minikube


//-----------------------------------------------------------------------------------------------------------------
            kubectl aka CLI and Context
//-----------------------------------------------------------------------------------------------------------------
kubectl (KUBE C-T-L or KUBE KUTTLE or Kube Control) is Kubernetes CLI
Communicates with teh apiserver
configuration stored locally:
    - ${HOME}/.kube/config
    - C:\Users\{USER}\.kube\config

K8s Context:
--------------------------
- A context is a group of access parameters to a K8s cluster
- Contains a Kubernetes cluster, a user, and a namespace
- The current context is the cluster that is curently the default for kubectl
    - All kubctl commands run against that cluster


kubectl config current-context                           # Get the curent context
Kubectl config get-contexts                              # List all context
Kubectl config use-context [contextName]                 # Set the current context
Kubectl config delete-context [contextName]              # Delete a context from the config fle

//-----------------------------------------------------------------------------------------------------------------
            Imperative way vs Declarative way in Kubernetes
//-----------------------------------------------------------------------------------------------------------------
Imperative:
  - Using kubectl commands, issue a series of commands to create esources 
  - Great for learning, testing and troubleshooting
  - It's like code
Declarative:
  - Using kubectl and YAML mainfests defining the resources that you need
  - Reproducible, repeatable
  - Can be saved in source control
  - It's like datat that can be parsed and modified



## Imperative

    kubectl create deployment mynginx1 --image=nginx

## Declarative

    kubectl create -f deploy-example.yaml

## Cleanup

    kubectl delete deployment mynginx1
    kubectl delete deploy mynginx2

kubectl get deploy                                     # To get list of deployment


** Note: Every .yaml file contains 'kind:' tag which determines underlying subset of kubectl functionality. Hence command 'kubectl create -f <.yaml>' would be repeated accross various topics
//-----------------------------------------------------------------------------------------------------------------
            Namespaces
//-----------------------------------------------------------------------------------------------------------------
- Allow to group resources. Ex. Dev, Test, Prod
- K8s creates a deafult workspace: default
- Objects in one namespace can access object in a different namespace.
    - Ex: objectname.prod.svc.cluster.local
- Deleting a namespace will delete all its child object


kubectl get namespace                                  # List all namespace
kubectl get ns                                         # List all namespace: Shortcut

kubectl config set-context --curent --namespace=[namespaceName]  # set the current contectto use a namespace

kubectl create ns [namespaceName]                      # Create a namespace

kubectl delete ns [namespaceName]                      # Delete a namespace

kubectl get pods --all-namespaces                      # List all pods in all namespace


//-----------------------------------------------------------------------------------------------------------------
            Kubernetes components
//-----------------------------------------------------------------------------------------------------------------
---------Master node----------

kube-apiserver
- REST Interface
- Save state to the datastor (etcd)
- All clients interact with it, never directly to the datastore


etcd
- Act as the cluster datastore for storing state
- Key-value stored
- Not a database or a datastore for application to use
- The single source of truth



kube-control-manager
- The controller of controllers!
- It runs controllers
  - Node controller
  - Replicate controller
  - Endpoints controller
  - Service account & Token controllers


cloud-control-manager
- Interact with the cloud providers controllers
  - Node
     - For cvhecking the cloud provider to determine if a node has been deleted in cloud after it stops responding
  - Route
     - For setting up routes in ther underlying cloud infrastruture
  - Service
     - For creating, updating and deleting cloud provider load balancer
  - Volume
     - For creating, attaching, and mounting volumes, and interacting with the cloud provider to orchestrate volumes.


Kube-scheduler
- Watches newly created pods that have no node assigned, and selects a node for them to run on
- Factors taken into  account for scheduling decisions include
  - individual and collective resource requirments
  - Hardware/software/policy constraints
  - Affinity and anti-affinity specifications
  - Data locality


Addons
- DNS
- Web UI (Dashboard)
- Cluster-level logging
- Container resource monitoring

---------Worker node----------

kube-proxy
- A network proxy
- Manages network rules on nodes

kubelet
- Manag the pods lifecycle
- Ensure that the container described in the Pod specs are running and healthy

container runtime
- K8s support several container runtimes
- Must implement the kubernetes Container Runtime Interface
  - Moby
  - Containerd
  - Cri-O
  - Rkt
  - Kata
  - Virtlet


Pods
- Atomic unit of the smallest unit of work of K8s
- Encapsulates an application's container
- Represents a unit of deployments
- Pods can run one or multiple container
- Container within a pod share
  - IP address space, mounted volumes
- Containers within a pod can communicate via
  - Localhost, IPC
- Pods are ephemeral
- Deploying a po is an atomic operation, it succeed or not
- If a pod fails, it is replaced with a new one with a shiny new IP address
- You don't update a pod, you replace it with an updated version
- You scale by adding more pods, not more containers in a pod


Pod Lifecycle:
Pod States are:
- Pending
  - Accepted but not yet created
- Running
  - Bound to a node
- Succeeded
  - Exited with Status 0
- Failed
  - All containers exit and at least  oe exited with non-zero status
- Unknow
  - Communication issues with the pod
- CrashLoopBackOff
  - Started, crashed, started again, and then creashed again
  
//-----------------------------------------------------------------------------------------------------------------
            Kubectl Pod commands
//-----------------------------------------------------------------------------------------------------------------

kubectl create -f [pod-definition.yml]                           # Create a pod

kubectl run [podname] --image=busybox -- /bin/sh -c "sleed 3600"     # Run a pod-definition

kubectl get pods                                                 # List the running pods

kubectl get pods -o wide                                         # Same but with more info

kubectl describe pod [Podname]                                   # Show pod info

kubectl get pood [podname] -o yaml > file.yaml                   # Extract the pod definition in YAML and save it to a file

kubectl exec -it [podname] -- sh                                 # Interactive mode

kubectl delete -f [pod-definition.yml]                           # delete a pod

kubectl delete pop [podname]                                     # same using the pod's name



Init containers: Runs inside pod before running application container. 
E.g. init container can run and check if database is up and running before running actual application container

- Alwayas runs to completion
- Each init container must complete successfully before the next one starts
- If ifails, the kubelet repeatedly restarts it until it succeeds
  - Unless it's restartPolicy is set to Never
- Probes are not supported
  - livenessProbe, readinessProbe, or startupProbe


//-----------------------------------------------------------------------------------------------------------------
            Selectors
//-----------------------------------------------------------------------------------------------------------------


Labels : Key-value pairs used to identify, describe and group related sets of objects or reources. These pairs are user defined.
Example:
  labels:
    app: myapp
    type: front-end


Refer: K8s-Fundamentals-HandsOn\L22-02 Selectors for exposing container as service on localhost


//-----------------------------------------------------------------------------------------------------------------
            Multi-containner Pods
//-----------------------------------------------------------------------------------------------------------------

Typical patterns - Sidecar
---------------------------
Container within Pod
  1. App: focuses on core buisness logic. E.g. it write some logs to files.
  2. Sidecar: Copy the log files to peristent storage (eg. storage provided by cloud provider)

Typical patterns - Adaptor
---------------------------

Typical patterns - Ambassador
---------------------------

Book: O'reilly  Designing Distrubuted Systems Patterns and paradigms for scalable, reliable services (Berndan Burns)


kubectl create -f [pod-definition.yml]                             # Create a pod

kubectl exec -it [podname] -c [containername] -- sh                # Exec into a pod

kubectl logs [podname] -c [containername]                          # Get the loogs for a container


---------------------
Networking Concepts:
---------------------
- All containers within a pod can communicate with each other (using local host by differnet port number)
- All pods can communicate with each other: Using service
- All nodes can communicate with all pods
- Pods are given an IP address (ephemeral i.e. lasting for a very short time)
- **Serices are given a persistent IP**
* External



//-----------------------------------------------------------------------------------------------------------------
            Workloads
//-----------------------------------------------------------------------------------------------------------------
A workload is an application running on Kubernetes
  - Pod
     - Represents a set of running containers
  - ReplicaSet
     - Primary method of managing pod replicas and theirlifecycle to privde set of self healing capability
  - Deployment
  - StatefulSet
  - Deamonset
    - Provide node-local facilities, such as storage driver or network plugin
  - Tasks that run to completion
    - Job
    - CronJob

ReplicaSet
-----------
  - Primary method of managing pod replicas and theirlifecycle to privde set of self healing capability
  - Their job is to always ensure the desired number of pods are running
  - While you can create ReplicaSets, the recommended way is to create Deployments


kubectl apply -f [definition.yaml]                             # Create a ReplicaSet

kubectl get rs                                                 # List ReplicaSets

kubectl describe rs [rsName]                                   # Get info

kubectl delete -f [definition.yaml]                            # Delete a ReplicaSet

kubectl delete rs [rsName]                                     # Same as above but using ReplicaSet name

Note: Using Deployment is better than ReplicaSet


Deployment
----------
- A deployment manage a single pod template
- You create a deployment for each microservice
  - front-end
  - back-end
  - image-procesor
  - creditcard-processor
- Deployments create ReplicaSets in the background
- Don't interact witht the ReplicaSets directly

* ReplicaSet provides self-healing and scalablility functionality *
* Deployment provides rolling updates and rollbacks functionality *


kubectl create deploy [deploymentName] --image=busybox --replicas=3 --port=80        # The imperative way

kubectl apply -f [definition.yaml]                             # Create a deployment

kubectl get deploy                                             # List deployments

kubectl describe deploy [deploymentName]                       # Get info

kubectl get rs                                                 # List ReplicaSets

kubectl delete -f [definition.yaml]                            # Delete a deployment

kubectl delete deploy [deploymentName]                         # Same but using the deployment name


DaemonSet
----------
- Ensures all Nodes (or a subset) run an instance of a Pod.
- Scheduled by the scheduler controller and run by the daemon controller.
- As nodes are added to the cluster Pods are added to them
- Typical uses
  - Running a cluster storage daemon.
  - Runing a logs collection daemon on every node.
  - Running a node monitoring on every node.

kubectl apply -f [definition.yaml]                             # Create a DaemonSet

kubectl get ds                                                 # List DaemonSet

kubectl describe ds [dsName]                                   # Get info

kubectl delete -f [definition.yaml]                            # Delete a DaemonSet

kubectl delete rs [dsName]                                     # Same as above but using DaemonSet name




StatefulSet
----------
- For Pods that must persist or maintain state
- Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods
- Each has a persistent identifier (name-x)
- If a pod dies, it is replced with another one using the idetifier
- Creates a series of pods in sequence from 0 to X and deletes them from X to 0.
- Typical uses:
  - Stable, unique network identifiers
  - Stable, databases using persistent storage

Warrnings:
- Containers are stateless by design
- StatefulSets offers a solution for stateful scenarios
- A better approach could be to use the Cloud provider database services
- Deleting a StatefulSet will not delete the PVCs
  - You have to do this manually.

A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory).

What is difference between PV and PVC?
A persistent volume (PV) is a piece of storage in the Kubernetes cluster, while a persistent volume claim (PVC) is a request for storage. 


kubectl apply -f [definition.yaml]                             # Create a StatefulSet

kubectl get sts                                                # List StatefulSet

kubectl describe sts [stsName]                                 # Get info

kubectl delete -f [definition.yaml]                            # Delete a StatefulSet

kubectl delete sts [stsName]                         # Same but using the StatefulSet name




Job
----------
- Workload for short lived tasks
- Creates one or more Pods and ensures that a specified number of them successfully terminate
- As pods successfully complete, the Job tracks the successful completions
- When  specified number of successful completions is reached, the Job complets
- By default, jobs with more than 1 pod will create them one after the other. To create them at the same time, add parallelism.

Note: restartPolicy should be set to Never as default is always.

kubectl create job [jobName] --image=busybox                   # The imperative way

kubectl apply -f [definition.yaml]                             # Create a Job

kubectl get job                                                # List Job

kubectl describe job [jobName]                                 # Get info

kubectl delete -f [definition.yaml]                            # Delete a Job

kubectl delete job [jobName]                                   # Same but using the Job name